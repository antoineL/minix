#!/bin/sh
#
#	mkboot 2.0 - Install a new revision
#							Author: Kees J. Bot

# This script could be run in cross-compilation builds:
: ${HOST_SH:=sh}
# It assumes $(dirname $0)/.. is the root of the source tree.

usage() {
	echo "Usage: $0 hdboot [DESTDIR]" >&2
	exit 1
}

find_real_root()
{
	[ `uname -s` = Minix ] || ( echo "Use DESTDIR if not under MINIX" >&2 ; usage )
	# We need the root device.
	root=`awk '$3=="/" { print $1; }' /etc/mtab`
	if [ -z "$root" ]
	then
		echo Root file system not found in /etc/mtab!
		exit 1
	fi
	if test "x$root" = "x/dev/ram"
	then # The root device is the ramdisk; try to find the original file system.
		ramimagename=$(sysenv ramimagename)
		if test -n "$ramimagename" -a -b "/dev/$ramimagename"
		then # Found! Now try to find the mounting point.
			root="/dev/$ramimagename"
			ramdisk_dir=`awk "\$1=\"$root\" {print \$3;}" /etc/mtab`
			if test -z "$ramdisk_dir"
			then # Not yet mounted; mount it temporarily to /mnt.
				umount /mnt 2>/dev/null || true
				mount $root /mnt
				DESTDIR=/mnt
			else # Already mounted; just redirect the script.
				DESTDIR=$ramdisk_dir
			fi
		fi
	fi
}

# If no DESTDIR specified, then act on / or on the current chroot
DESTDIR=
# Check arguments.
case "$#:$1" in
1:hdboot 1:rotate )
	action=$1
	rootfs=1
	find_real_root
	;;
2:hdboot 2:rotate )
	action=$1 DESTDIR=$2
	rootfs=0 # Do not try to guess where the real root FS is...
	;;
*)	usage
esac

case $action in
rotate)
	# Rotate system processes. We assume latest ones are in
	# /boot/minix/.temp and we maintain /boot/minix/ by ourselves.
	# Note that a "known-good" old image is kept in /boot/minix_default
	# and is not touched by this action.

	set -- `ls -t "$DESTDIR/boot/minix"`

	[ "x$1" != "x.temp" ] || shift # do not consider recently added .temp

	case $# in
	0|1|2)
		# Not much there, do not remove a thing.
		;;
	*)
		# Remove the third-newest and older image(s) in /boot/minix/
		shift; shift # Keep two most recent images
		echo "rm /boot/minix/$*"
		cd $DESTDIR/boot/minix && rm -rf "$@"
	esac
	;;

hdboot)
	version=`${HOST_SH} $(dirname $0)/../sys/conf/osrelease.sh`

	# Retrieve the git revision; this only succeeds
	# if git is available, it's a git checkout, *and*
	# there are no uncommitted changes.
	if git diff --quiet 2>/dev/null
	then	gitrev="-`git describe --always`"
	fi

	revision=`cat revision 2>/dev/null`

	oldrev=$revision

	if [ -z "$revision" ]
	then
		revision=0
		rrevision=""
		gitrev=""
	else
		revision=`expr $revision + 1`
		rrevision=r$revision
	fi

	target="${version}${rrevision}${gitrev}"

	[ -d $DESTDIR/boot/minix/.temp ] || exit 1
	rm -rf $DESTDIR/boot/minix/"$target"/
	echo "New system image at " $root:/boot/minix/"$target"/
	mv $DESTDIR/boot/minix/.temp $DESTDIR/boot/minix/"$target"
	rm -f $DESTDIR/boot/minix_latest
	ln -s minix/"$target" $DESTDIR/boot/minix_latest 

	# Save the revision number.
	test "$revision" != "$oldrev" && echo $revision >revision

	[ $rootfs -a -n "$DESTDIR" ] && umount $root

	echo "Done."
	;;
esac
sync
exit 0
